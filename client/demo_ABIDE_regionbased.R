#!/usr/bin/env Rscript
#
# Runs a general linear model (GLM) analysis of region-based brain morphometry data.
# The data have typically been generated by FreeSurfer using some brain atlas.
#
# Written by Tim SchÃ¤fer, 2022-01-22

library("brainnet");
library("fsbrain");   # loading neuroimaging data and visualizing results.
library("readxl");    # read Excel demographcis file
library("MatchIt");   # matching of patient/control groups
library("ggplot2");   # general purpose plots
#library("slmtools");  # internal R package of Ecker neuroimaging group for mass-univariate GLM analysis. not needed for this version of the script.

################################################################################
########################## Load data and demographics ##########################
################################################################################

do_plot=FALSE;

if(brainnet:::get_os() == "linux") {
    study_dir = "~/nas/projects/abide";
    if(! dir.exists(study_dir)) {
        study_dir = sprintf("/media/%s/science/data/abide", Sys.getenv("LOGNAME"));
    }
} else {
    study_dir = "/Volumes/shared/projects/abide";
}

if(dir.exists("~/data/abide_min")) {
    study_dir = "~/data/abide_min"; # use local minimal data dir if available, loading from a local SSD is much faster than loading via LAN from the NAS.
}

subjects_dir = file.path(study_dir, "structural"); # the FreeSurfer SUBJECTS_DIR containing the neuroimaging data.
if(! dir.exists(subjects_dir)) {
    stop(sprintf("The subjects_dir '%s' does not exist.\n", subjects_dir));
}

md = load_ABIDE_metadata_males(impute_data = TRUE);
demographics = md$merged; # Extract the field that contains the merged brainstats and demographics.

##### TODO: Create your own sample here. The sample should be a subset of the available data (rows) in the data.frame 'demographics' that must:
#####         1) follow your inclusion criteria (=> e.g.,define a suitable age range for your research question and filter the subjects accordingly)
#####         2) not include bad quality scans (=> perform some sort of quality inspection of the data and filter subjects that do not pass the quality criteria)
#####         3) achieve at least approximate balance between covariates for the groups (=> check for significant iq/age/... differences between controls and cases and reduce them using matching).


subjects_list = as.character(demographics$subject_id);

subjects_control = subjects_list[demographics$group == "control"];
subjects_asd = subjects_list[demographics$group == "asd"];
cat(sprintf("Working with %d subjects in total: %d ASD and %s controls.\n", length(subjects_list), length(subjects_asd), length(subjects_control)));
if(length(subjects_asd) + length(subjects_control) != length(subjects_list)) {
    stop("Invalid group assignment to case/control (or more than 2 groups).");
}

measure="thickness";  ## The native space descriptor to load from the subjects 'surf' directory, its values will be aggregated with the atlas regions (see 'atlas' below).
hemi="split";   ## For which hemisphere to compute the results. One of 'lh' for left only, 'rh' for right only, or 'split' to compute (separately) for both hemispheres.
atlas="aparc";  ## The atlas you want, 'aparc' for Desikan-Killiany atlas, 'aparc.a2009s' for Destrieux atlas, 'aparc.DKTatlas40' for DKT atlas, or your custom atlas. See https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation for details.


## Aggregate the native space data by atlas region. Alternatively, one could load a CSV file produced by the FreeSurfer tool 'aparcstats2table'.
braindata = fsbrain::group.agg.atlas.native(subjects_dir, subjects_list, measure=measure, hemi=hemi, atlas=atlas, cache_file = sprintf("cache_ABIDE_%s_%s_%s.Rdata", measure, hemi, atlas));
# fsbrain::vis.subject.morph.native(subjects_dir, "UM_1_0050272", measure = "thickness");
# fsbrain:::qc.for.group(subjects_dir, subjects_list, measure = "thickness", atlas = "aparc");

## Remove some columns (atlas regions) we do not want. This is atlas-specific.
braindata$lh_corpuscallosum = NULL; # The corpus callosum is not part of the cortex, this is the medial wall that must be ignored.
braindata$rh_corpuscallosum = NULL; # Same for other hemisphere.
braindata$lh_unknown = NULL; # This should be empty (no vertices), and it will thus lead to all kinds of trouble if included. It is also pointless to include it as it is not a real brain region.
braindata$rh_unknown = NULL; # Same for other hemisphere.

## Merge the brain data with the demographics.
glm_data = base::merge(demographics, braindata, by.x="subject_id", by.y="subject");

## Run the GLMs (on per atlas region/hemi)
considered_atlas_regions = names(braindata);
considered_atlas_regions = considered_atlas_regions[considered_atlas_regions != "subject"];

region_idx = 1L;
region_fits = list();
pvalues_group = list();
effect_sizes_group = list();
for(region_name in considered_atlas_regions) {
    cat(sprintf("### Handling Region '%s' (%d of %d). ###\n", region_name, region_idx, length(considered_atlas_regions)));
    formula_region = sprintf("%s ~ group + age + iq + site + totalMeanCorticalThickness", region_name); # we do not use gender because the sample is all male.
    fit = glm(formula = formula_region, data = glm_data, family=gaussian());
    region_fits[[region_name]] = fit;
    pvalues_group[[region_name]] = unname(coef(summary.glm(region_fits[[region_name]]))[2,4]);   ## You can change the numbers here to access data for other predictors, the default is main effect of group (due to the order in the formula above).

    raw_sd_case = sd(glm_data[[region_name]][glm_data$group == "asd"]);
    raw_sd_control = sd(glm_data[[region_name]][glm_data$group == "control"]);
    raw_sd_pooled = sqrt((raw_sd_case * raw_sd_case + raw_sd_control + raw_sd_control) / 2.0);
    effect_group_case_mean = effects::effect("group", fit)$fit[1];
    effect_grou_control_mean = effects::effect("group", fit)$fit[2];
    cohen_d = (effect_group_case_mean - effect_grou_control_mean) / raw_sd_pooled;
    effect_sizes_group[[region_name]] = abs(cohen_d); # we are not interested in direction for effect size.

    region_idx = region_idx + 1L;
}

# Investigate region_fits and pvalues_group.

## Prints stats for a single region
#fit = region_fits$lh_bankssts;
#summary(fit);
#plot(effects::allEffects(fit)); # https://www.jstatsoft.org/article/view/v008i15/effect-displays-revised.pdf

## Visualize values for all regions.
effect_sizes_by_hemi = fsbrain::hemilist.from.prefixed.list(effect_sizes_group); # split the single list with lh_ and rh_ prefixes into two lh and rh lists.
cm_eff = fsbrain::vis.region.values.on.subject(fsbrain::fsaverage.path(), 'fsaverage', lh_region_value_list = effect_sizes_by_hemi$lh, rh_region_value_list = effect_sizes_by_hemi$rh, atlas = "aparc", views = NULL);
fsbrain::export(cm_eff, colorbar_legend = "Cohens d", output_img = "abide_regions_group_cohen_d.png");

pvalues_by_hemi = fsbrain::hemilist.from.prefixed.list(pvalues_group); # split the single list with lh_ and rh_ prefixes into two lh and rh lists.
cm_p = fsbrain::vis.region.values.on.subject(fsbrain::fsaverage.path(), 'fsaverage', lh_region_value_list = pvalues_by_hemi$lh, rh_region_value_list = pvalues_by_hemi$rh, atlas = "aparc", views = NULL);
fsbrain::export(cm_p, colorbar_legend = "p value for group effect", output_img = "abide_regions_group_pvalue.png");



